{"$defs":{"Activation":{"anyOf":[{"$ref":"#/$defs/ReLU"},{"$ref":"#/$defs/GeLU"}]},"AdamSpec":{"description":"Adam: Adaptive Moment Estimation","properties":{"learning_rate":{"description":"Step size for the optimizer (~gradient) updates. May be modified by a scheduler.","exclusiveMinimum":0,"title":"Learning rate.","type":"number"},"optimizer":{"const":"adam","title":"Optimizer","type":"string"}},"required":["learning_rate","optimizer"],"title":"AdamSpec","type":"object"},"AlgorithmicSpec":{"description":"Specification of the \"algorithmic\" parts of the program.\n\nThis includes the values used for the parameters of the \"deterministic\"\npart of the algorithm.","properties":{"guided_filter_patch_radius":{"description":"Patch radius used in the guided filter when refining the coarse transmission map. Defined as the number of pixels from the center to any side of the square, without counting the center itself.","examples":[12,16,20],"minimum":0,"title":"Patch radius for the guided filter","type":"integer"},"guided_filter_regularization_coefficient":{"description":"Coefficient used for weighing the square L^2 norm of patch means in the guided filter refinement of the coarse transmission map.","examples":[0.01,0.0001],"exclusiveMinimum":0,"title":"Regularization coefficient for the guided filter","type":"number"},"step_size":{"description":"Step size of the analytical proximity operator. That is, the step size used for the proximity operator associated to the dual variable.","examples":[0.01,0.005],"exclusiveMinimum":0,"title":"Step size","type":"number"},"transmission_map_patch_radius":{"description":"Patch radius used for estimating the coarse transmission map. Defined as the number of pixels from the center to any side of the square, without counting the center itself.","examples":[6,8,10],"minimum":0,"title":"Patch radius for the transmission map estimation","type":"integer"},"transmission_map_saturation_coefficient":{"description":"Coefficient used for weighing saturation maps when estimating transmission maps. This corresponds to \\lambda in https://doi.org/10.1109/TCSVT.2021.3115791.\nThis should be a positive real number, ideally between 0 and 1 and close to 1.","examples":[0.5,0.7],"minimum":0,"title":"Saturation coefficient for the transmission map estimation","type":"number"}},"required":["guided_filter_patch_radius","guided_filter_regularization_coefficient","step_size","transmission_map_patch_radius","transmission_map_saturation_coefficient"],"title":"AlgorithmicSpec","type":"object"},"AvgPoolSpec":{"properties":{"kernel_size":{"default":2,"description":"Size of the kernel to use for pooling. Refers to the side of the (square) kernel; not its radius.","title":"Kernel Size","type":"integer"},"stride":{"default":2,"description":"Stride to use for pooling. The same for all directions.","title":"Stride","type":"integer"},"method":{"const":"avg","title":"Method","type":"string"}},"required":["method"],"title":"AvgPoolSpec","type":"object"},"ColorCosineSimilarityLossSpec":{"properties":{"weight":{"minimum":0,"title":"Weight","type":"number"},"loss":{"const":"color_cosine_similarity","title":"Loss","type":"string"}},"required":["weight","loss"],"title":"ColorCosineSimilarityLossSpec","type":"object"},"ConsistencyLossSpec":{"properties":{"weight":{"minimum":0,"title":"Weight","type":"number"},"loss":{"const":"consistency","title":"Loss","type":"string"}},"required":["weight","loss"],"title":"ConsistencyLossSpec","type":"object"},"CosineAneallingLRSpec":{"description":"Varies the learning rate between its initial value and a lower bound\nin a sinusoidal fashion, starting with a peak (cosine).","properties":{"scheduler":{"const":"cosine_annealing_lr","title":"Scheduler","type":"string"},"semiperiod":{"description":"Half of the period of the cosine. Corresponds to pytorch's T_max.","exclusiveMinimum":0,"title":"Semiperiod","type":"integer"},"minimum_learning_rate":{"default":0,"description":"Minimum value for the learning rate. This lower bound is achieved whenever the cosine reachs its minimum.","minimum":0,"title":"Minimum learning rate","type":"number"}},"required":["scheduler","semiperiod"],"title":"CosineAneallingLRSpec","type":"object"},"DatasetSpec":{"properties":{"path":{"format":"path","title":"Path","type":"string"},"eager_load":{"title":"Eager Load","type":"boolean"},"n_epochs":{"exclusiveMinimum":0,"title":"N Epochs","type":"integer"},"batch_size":{"exclusiveMinimum":0,"title":"Batch Size","type":"integer"},"name":{"const":"uieb","title":"Name","type":"string"}},"required":["path","eager_load","n_epochs","batch_size","name"],"title":"UiebSpec","type":"object"},"ExecSpec":{"properties":{"mode":{"const":"exec","title":"Mode","type":"string"},"input":{"description":"A list with the paths to the images to be processed.","items":{"format":"path","type":"string"},"title":"Input images","type":"array"},"output_dir":{"description":"Where to store the processed images. The output images will have the same names as the inputs, but paths relative to this directory.","format":"path","title":"Directory for output images","type":"string"},"override_dir_contents":{"default":false,"description":"Whether to override existing files in `output_dir` with the same names as the inputs.","title":"Override Dir Contents","type":"boolean"}},"required":["mode","input","output_dir"],"title":"ExecSpec","type":"object"},"FidelityLossSpec":{"properties":{"weight":{"minimum":0,"title":"Weight","type":"number"},"loss":{"const":"fidelity","title":"Loss","type":"string"}},"required":["weight","loss"],"title":"FidelityLossSpec","type":"object"},"GeLU":{"properties":{"name":{"const":"gelu","title":"Name","type":"string"}},"required":["name"],"title":"GeLU","type":"object"},"GroundTruthLossSpec":{"properties":{"weight":{"minimum":0,"title":"Weight","type":"number"},"loss":{"const":"ground_truth","title":"Loss","type":"string"}},"required":["weight","loss"],"title":"GroundTruthLossSpec","type":"object"},"L2PoolSpec":{"properties":{"kernel_size":{"default":2,"description":"Size of the kernel to use for pooling. Refers to the side of the (square) kernel; not its radius.","title":"Kernel Size","type":"integer"},"stride":{"default":2,"description":"Stride to use for pooling. The same for all directions.","title":"Stride","type":"integer"},"method":{"const":"l2","title":"Method","type":"string"}},"required":["method"],"title":"L2PoolSpec","type":"object"},"LRSchedulerSpec":{"anyOf":[{"$ref":"#/$defs/StepLRModel"},{"$ref":"#/$defs/CosineAneallingLRSpec"},{"$ref":"#/$defs/ReduceLROnPlateauSpec"}]},"LossSpec":{"anyOf":[{"$ref":"#/$defs/ColorCosineSimilarityLossSpec"},{"$ref":"#/$defs/ConsistencyLossSpec"},{"$ref":"#/$defs/FidelityLossSpec"},{"$ref":"#/$defs/GroundTruthLossSpec"}]},"MaxPoolSpec":{"properties":{"kernel_size":{"default":2,"description":"Size of the kernel to use for pooling. Refers to the side of the (square) kernel; not its radius.","title":"Kernel Size","type":"integer"},"stride":{"default":2,"description":"Stride to use for pooling. The same for all directions.","title":"Stride","type":"integer"},"method":{"const":"max","title":"Method","type":"string"}},"required":["method"],"title":"MaxPoolSpec","type":"object"},"NeuralNetworkSpec":{"description":"Config for a UNet-like architecture","properties":{"name":{"const":"unet","title":"Name","type":"string"},"activation":{"discriminator":{"mapping":{"gelu":"#/$defs/Activation","relu":"#/$defs/Activation"},"propertyName":"name"},"oneOf":[{"$ref":"#/$defs/Activation"}],"title":"Activation function"},"pooling":{"discriminator":{"mapping":{"avg":"#/$defs/PoolSpec","l2":"#/$defs/PoolSpec","max":"#/$defs/PoolSpec"},"propertyName":"method"},"oneOf":[{"$ref":"#/$defs/PoolSpec"}],"title":"Pooling function specification"},"channels_per_layer":{"description":"Number of channels in each decoder/encoder sublayer, and the bottleneck.\nThe number of channels of a layer is defined as the number of channels of the output of the respective encoder and decoder step (which is the same for both).The number of channels of the bottleneck is defined as the number of channels of its intermediate blocks. The last element of this list is parsed as the number of channels of the bottleneck. The rest are parsed, from left to right, as the numbers of channels of the encoder/decoder layers, in execution order.","examples":[4,8,16],"items":{"type":"integer"},"title":"Channels per layer","type":"array"},"sublayers_per_step":{"description":"Number of Conv2d sublayers in each encoder/decoder layer, and in the bottleneck.","minimum":3,"title":"Sublayers per step","type":"integer"}},"required":["name","activation","pooling","channels_per_layer","sublayers_per_step"],"title":"UNetConfig","type":"object"},"OptimizerSpec":{"anyOf":[{"$ref":"#/$defs/AdamSpec"},{"$ref":"#/$defs/SGDSpec"}]},"PoolSpec":{"anyOf":[{"$ref":"#/$defs/MaxPoolSpec"},{"$ref":"#/$defs/AvgPoolSpec"},{"$ref":"#/$defs/L2PoolSpec"}]},"ReLU":{"properties":{"name":{"const":"relu","title":"Name","type":"string"}},"required":["name"],"title":"ReLU","type":"object"},"ReduceLROnPlateauSpec":{"description":"Multiplies the learning rate by a small constant after a number of\nconsecutive steps without a signficant loss decrease.","properties":{"scheduler":{"const":"reduce_lr_on_plateau","title":"Scheduler","type":"string"},"factor":{"description":"Factor by which to multiply the learning rate.","exclusiveMinimum":0,"title":"Factor","type":"number"},"patience":{"description":"Number of consecutive non-significant steps that are awaited before reducing the learning rate.","minimum":0,"title":"Patience","type":"integer"},"threshold":{"description":"Relative threshold by which to consider a step as not signficant. Concretely, a step is considered signficant if its current loss is smaller than (1-threshold) times the loss at the last signficant step. The only exception to this is first step, which is always signficant.","title":"Threshold","type":"number"}},"required":["scheduler","factor","patience","threshold"],"title":"ReduceLROnPlateauSpec","type":"object"},"SGDSpec":{"description":"Stochastic Gradient Descent","properties":{"learning_rate":{"description":"Step size for the optimizer (~gradient) updates. May be modified by a scheduler.","exclusiveMinimum":0,"title":"Learning rate.","type":"number"},"optimizer":{"const":"sgd","title":"Optimizer","type":"string"},"momentum":{"description":"Multiplicative coefficient assigned to the second-to-lastcomputed gradient when updating weights.","minimum":0,"title":"Momentum","type":"number"}},"required":["learning_rate","optimizer","momentum"],"title":"SGDSpec","type":"object"},"StepLRModel":{"description":"Multiplies the learning rate by a fixed quantity each given number of\nsteps.","properties":{"scheduler":{"const":"step_lr","title":"Scheduler","type":"string"},"step_size":{"description":"Number of steps elapsed between multiplications.","exclusiveMinimum":0,"title":"Step size","type":"integer"},"factor":{"description":"Multiplicative coefficient to apply.","exclusiveMinimum":0,"title":"Factor","type":"number"}},"required":["scheduler","step_size","factor"],"title":"StepLRModel","type":"object"},"TrainSpec":{"properties":{"mode":{"const":"train","title":"Mode","type":"string"},"optimizer_spec":{"description":"Optimizer specification.","discriminator":{"mapping":{"adam":"#/$defs/OptimizerSpec","sgd":"#/$defs/OptimizerSpec"},"propertyName":"optimizer"},"oneOf":[{"$ref":"#/$defs/OptimizerSpec"}],"title":"Optimizer"},"learning_rate_scheduler_spec":{"description":"Learning rate scheduler specification.","discriminator":{"mapping":{"cosine_annealing_lr":"#/$defs/LRSchedulerSpec","reduce_lr_on_plateau":"#/$defs/LRSchedulerSpec","step_lr":"#/$defs/LRSchedulerSpec"},"propertyName":"scheduler"},"oneOf":[{"$ref":"#/$defs/LRSchedulerSpec"}],"title":"LR scheduler"},"dataset_spec":{"$ref":"#/$defs/DatasetSpec","description":"Specifications for the dataset used to train the model.\nAlso includes information about the number of epochs and how to load the dataset.","title":"Dataset specification"},"losses":{"items":{"description":"Specification for the loss functions to be used.\nThe final loss function will be the sum of the losses specified in this attribute.","discriminator":{"mapping":{"color_cosine_similarity":"#/$defs/LossSpec","consistency":"#/$defs/LossSpec","fidelity":"#/$defs/LossSpec","ground_truth":"#/$defs/LossSpec"},"propertyName":"loss"},"oneOf":[{"$ref":"#/$defs/LossSpec"}],"title":"Loss function specification"},"title":"Losses","type":"array"}},"required":["mode","optimizer_spec","learning_rate_scheduler_spec","dataset_spec","losses"],"title":"TrainSpec","type":"object"}},"properties":{"mode_spec":{"discriminator":{"mapping":{"exec":"#/$defs/ExecSpec","train":"#/$defs/TrainSpec"},"propertyName":"mode"},"oneOf":[{"$ref":"#/$defs/TrainSpec"},{"$ref":"#/$defs/ExecSpec"}],"title":"Mode"},"neural_network_spec":{"$ref":"#/$defs/NeuralNetworkSpec","title":"Neural network specification"},"algorithmic_spec":{"$ref":"#/$defs/AlgorithmicSpec","title":"Algorithmic specification"},"log_level":{"enum":["debug","train","warning","error","critical"],"title":"Log level","type":"string"}},"required":["mode_spec","neural_network_spec","algorithmic_spec","log_level"],"title":"U2FoldSpec","type":"object"}